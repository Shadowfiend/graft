{"name":"Graft","body":"# Graft\r\n\r\n**Proposition:** my view should be viewable as plain HTML without a server while\r\nI'm designing/styling it, and data should be bound on top of it as easily as\r\npossible.\r\n\r\n**Solution:** graft.\r\n\r\n**Props to/superheavy inspiration from:** [Lift][].\r\n\r\n**Also see:** A very similar library from the folks at [nodejitsu][], [weld][].\r\n\r\n**Built on:** The awesomeness of [jsdom][] (also from the folks at nodejitsu).\r\n\r\n[lift]: http://liftweb.net/\r\n[nodejitsu]: http://nodejitsu.com/\r\n[weld]: https://github.com/hij1nx/weld\r\n[jsdom]: https://github.com/tmpvar/jsdom\r\n\r\n## Usage\r\n\r\nThere are several possible usages:\r\n\r\n    $('li.template')\r\n      .graft('.author', authorName) // sets .author elements' text to authorName\r\n      .graft('.author',\r\n        $('a')\r\n          .text(authorName)\r\n          .href('link-to-author')) // sets .author elements' html to resulting anchor element\r\n      .graft('.author',\r\n        function($elt) {\r\n          $elt.text(item.creatorName);\r\n        }) // passes the selected elements in for mutation\r\n      .graft('.author',\r\n        {\r\n          '.name': authorName,\r\n          '.link': $('a').text(authorName).href('link-to-author')\r\n        }) // does a graft on each of these sub-elements\r\n      .graft(\r\n        {\r\n          '.author': authorName,\r\n          '.link': $('<a>').text(authorName).attr('href', 'link-to-author')\r\n        }) // as above, but searches the top-level object instead of a sub-object\r\n\r\nIf the graft call is invoked on an element with class 'template', it\r\nwill clone that element and remove the template class, add the resulting\r\nelement to the same container, and then return the new resulting element. If,\r\non the other hand, the graft call is invoked on an element without that class,\r\nit will operate directly on the element and return it.\r\n\r\n## Collections\r\n\r\nFor collections of items, we take a similar tack. It would suck to have to use\r\na double-function for each collection (one for iteration and one for graft), so\r\nwe do some goodness:\r\n\r\n    $('ul')\r\n      .graft('li.template',\r\n        authors.map(function(author) {\r\n          return {\r\n            '.author': author.name,\r\n            '.link': $('a').text(author.name).href(linkFor(author)),\r\n          }\r\n        })\r\n\r\nThe mechanism is straightforward: if you pass an array as the second parameter,\r\neach object in the array is passed to graft in turn, each with a new clone of\r\nthe matched element(s). Then, these elements are gathred up and put into the\r\nDOM instead of the matched element. This means you provide an array of\r\nfunctions, if you prefer, or an object, as above, or a string, etc.\r\n\r\nThe goodness is good, no?\r\n\r\n## Easily Setting Attributes\r\n\r\nGraft adds just a little bit of bam-bam-bam to selectors:\r\n\r\n    $('li.template')\r\n      .graft({\r\n        '.author': author.name,\r\n        '.link[href]': linkFor(author)\r\n      })\r\n\r\nThis lets us set the href with zero effort. The downside is, the above selector\r\nalso means `elements with class link that have an attribute href'. I've found\r\nthat is fairly rarely used, but if you still want to use it, just put a space\r\nat the end of the selector:\r\n\r\n    $('li.template')\r\n      .graft({\r\n        '.author': author.name,\r\n        '.link[href] ': function($elt) { /* do stuff with the link */ }\r\n      })\r\n\r\nWe're not *quite* done yet, however. There is also a dash of goodness for\r\nadding to an attribute (particularly handy for classes):\r\n\r\n    $('li.template')\r\n      .graft({\r\n        '.author': author.name,\r\n        '.link[class+]': author.category\r\n      })\r\n\r\n## CoffeeScript\r\n\r\nGraft is written in CoffeeScript (though a compiled JS version is included)\r\nbecause CoffeeScript is kind of gorgeous. It also benefits from CoffeeScript's\r\nprettiness in use. For example:\r\n\r\n    $('ul')\r\n      .graft 'li.template', authors.map (author) ->\r\n          '.author, .link': author.name,\r\n          '.link[class+]': author.category\r\n          '.about-me':\r\n            '.avatar[src]': avatarFor(author),\r\n            '.description': author.description\r\n\r\n## Node.js\r\n\r\nFor node.js, the module exports a function that lets you just pass in HTML or\r\nthe name of a file containing HTML and run with it. We can use it as follows:\r\n\r\n    var graft = require('graft').graft;\r\n    graft('<p>My <a href=\"place.html\">HTML</a></p><div>magic</div>',\r\n      {\r\n        'p a[href]': 'http://google.com',\r\n        'div': 'unicorns!'\r\n      },\r\n      function(errors, grafted) {\r\n        response.send(grafted, { 'Content-Type': 'text/html' }, 200);\r\n      });\r\n\r\nIf you need access to the jQuery object (for example, because you want to\r\ncreate some elements to graft in), graft exposes an easier method for doing\r\nthat, withjQuery:\r\n\r\n    var graft = require('graft').graft,\r\n        withjQuery = graft.withjQuery;\r\n\r\n    withjQuery('<p>My <a href=\"place.html\">HTML</a></p><div>magic</div>', function(errors, $) {\r\n      $('body')\r\n        .graft({\r\n          'p a[href]': 'http://google.com',\r\n          'div': $('<p>').text('unicorns!')\r\n        })\r\n    });\r\n\r\nThis lets you use jQuery directly when your use case requires it. You will then\r\nhave to manually convert the jQuery results back to HTML:\r\n\r\n    var graft = require('graft').graft,\r\n        withjQuery = graft.withjQuery;\r\n\r\n    withjQuery('<p>My <a href=\"place.html\">HTML</a></p><div>magic</div>', function(errors, $) {\r\n      $('body')\r\n        .graft({\r\n          'p a[href]': 'http://google.com',\r\n          'div': $('<p>').text('unicorns!')\r\n        });\r\n\r\n      response.send(\"<html>\" + $('html').html() + \"</html>\", { 'Content-Type': 'text/html' }, 200);\r\n    });\r\n\r\nGraft exposes an htmlize function for this purpose, which is passed in as a third parameter:\r\n\r\n    var graft = require('graft').graft,\r\n        withjQuery = graft.withjQuery;\r\n\r\n    withjQuery('<p>My <a href=\"place.html\">HTML</a></p><div>magic</div>', function(errors, $, htmlize) {\r\n      $('body')\r\n        .graft({\r\n          'p a[href]': 'http://google.com',\r\n          'div': $('<p>').text('unicorns!')\r\n        });\r\n\r\n      response.send(htmlize(), { 'Content-Type': 'text/html' }, 200);\r\n    });","tagline":"Templating that doesn't suck... for Node and the browser.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}