################################################################################
# Graft                                                                        #
# Templating that doesn't suck... for Node and the browser.                    #
#                                                                              #
# Copyright 2010-2012 Antonio Salazar Cardozo                                  #
# Released under the terms of the MIT License.                                 #
################################################################################

jsdom = require('jsdom')

###
Proposition: my view should be viewable as plain HTML without a server while
I'm designing/styling it, and data should be bound on top of it as easily as
possible.

Solution: graft.

There are several possible usages:

  $('li.template')
    .graft('.author', authorName) // sets .author elements' text to authorName
    .graft('.author',
      $('a')
        .text(authorName)
        .href('link-to-author')) // sets .author elements' html to resulting anchor element
    .graft('.author',
      function($elt) {
        $elt.text(item.creatorName);
      }) // passes the selected elements in for mutation
    .graft('.author',
      {
        '.name': authorName,
        '.link': $('a').text(authorName).href('link-to-author')
      }) // does a graft on each of these sub-elements
    .graft(
      {
        '.author': authorName,
        '.link': $('a').text(authorName).href('link-to-author')
      }) // as above, but searches the top-level object instead of a sub-object
    .graft({
      '.author': author.name,
      '.link[href]': linkFor(author) // sets the href attribute
      '.link[class+] ': author.category // adds the category to the class attribute
      '.other-link[target] ': 'EXTERNAL' // targets other-links with a target attribute (note space at the end)
      '.other-link[target=_blank]': 'new window' // targets other-links with a target attribute _blank
    })

If the graft call is invoked on an element with class `template', it
will clone that element and remove the template class, add the resulting
element to the same container, and then return the new resulting element. If,
on the other hand, the graft call is invoked on an element without that class,
it will operate directly on the element and return it.

For example, invoking graft on an element:

    <div class="name">Name</div>

As:

    $('.name').graft('Wolverine');

Would replace the name in the element above. Doing the same thing on the element:

    <div class="template name">Name</div>

Would instead result in a new element alongside the original:

    <div class="template name">Name</div>
    <div class="name">Wolverine</div>

Collections
-------------

For collections of items, we take a similar tack. It would suck to have to use
a double-function for each collection (one for iteration and one for graft), so
we do some goodness:

  $('ul')
    .graft('li.template',
      authors.map(function(author) {
        return {
          '.author': author.name,
          '.link': $('a').text(author.name).href(linkFor(author)),
        }
      })

AJAX Forms
----------

Graft can set up a form to be submitted via AJAX for you. When you do this,
graft gives the form an action URI that is generated by Graft (this URI is
unique per form generation, and disabled immediately unless otherwise
specified, thus also acting as a guard against replay attacks).

###
addGraft = (jQuery) ->
  $ = jQuery
  $.fn.graft = (selector, generators, interceptors) ->
    $original = $base = this
    if $original.is('.template')
      $base = $base.clone().removeClass('template')

    # If the selector is an object, it means we're grafting sub-selectors of
    # the top-level object.
    if typeof selector == 'object'
      interceptors = generators

      $base.graft subselector, generator, interceptors for subselector, generator of selector
    else
      if interceptors?
        for interceptor in interceptors
          halt = interceptor($base, selector, generators)

          return if halt

      switch typeof generators
        # Functions get passed the result of the selector.
        when 'function'
          generators $base.find(selector)
        # Strings are text for replacing the text of the selector matches, or
        # if mixed with attribute selectors for setting or adding to attribute
        # values.
        when 'string' or 'number'
          match = null
          if match = /(.*)\[([^\]]+)\]$/.exec(selector)
            [strippedSelector, attribute] = match[1..]

            if attribute.charAt(attribute.length - 1) == '+'
              attribute = attribute.substring(0, attribute.length - 1)

              $base
                .find(strippedSelector)
                .each (i, elt) ->
                  $(elt).attr(attribute, "#{$(elt).attr(attribute)} #{generators}")
            else
              $base.find(strippedSelector).attr(attribute, generators)
          else
            $base.find(selector).text(generators)
        when 'object'
          # If we get a jQuery object (identified by the selector property), we
          # replace the selector matches' html contents with that object's
          # contents.
          if generators.selector?
            $base.find(selector).html(generators)
          # If we get an array, identified by a map property, we iterate
          # through it, grafting its components to clones of the base, then
          # returning them as one group.
          # FIXME This will cause issues in older browsers.
          else if generators.map?
            $toGraft = $base.find(selector)
            generators.map((generator) ->
              generatorType = typeof generator

              if generatorType == 'object'
                $toGraft.clone().graft generator
              else if generatorType == 'string' || generatorType == 'number'
                $toGraft.clone().text generator
              else if generatorType == 'function'
                $toGraft.clone().each generator
            ).forEach ($generated) ->
              $toGraft.before($generated)

            $toGraft.remove()

          # If we get a non-jQuery object, we just run graft all the properties as
          # selectors with their values as generators.
          else
            $base.find(selector).graft subselector, generator for subselector, generator of generators

    # If we are a template, append the result to the original template's
    # parent.
    if $original.is('.template')
      $original.replaceWith $base

    $base

graft = (html, generators, callback) ->
  window = jsdom.jsdom(html).createWindow()
  try
    jsdom.jQueryify window, "#{__dirname}/jquery-1.5.js", ->
      jquery = window.jQuery

      addGraft jquery
      jquery('html').graft generators, graft.interceptors

      callback null, "<html>#{jquery('html').html()}</html>"
  catch error
    callback error

graft.interceptors = []

graft.withjQuery = (html, callback) ->
  try
    window = jsdom.jsdom(html).createWindow()

    jsdom.jQueryify window, "#{__dirname}/jquery-1.5.js", ->
      jquery = window.jQuery

      addGraft jquery

      callback null, jquery, -> "<html>#{jquery('html').html()}</html>"
  catch error
    callback error

exports.graft = graft

